
Hoplink
https://fea3eaujgt6thx3kpoyohw1r4x.hop.clickbank.net
/**
 * fraud-protect-app.js
 * Minimal layered fraud protection example (Express)
 *
 * Features:
 * - Rate limiter with Redis fallback
 * - Simple device/IP fingerprint
 * - Risk scoring engine (rules)
 * - Challenge escalation: allow / require captcha or 2FA or block
 * - Event logging and webhook alert
 */

const express = require('express');
const rateLimit = require('express-rate-limit');
const RedisStore = require('rate-limit-redis');
const redis = require('redis');
const geoip = require('geoip-lite');
const bodyParser = require('body-parser');
const fetch = require('node-fetch'); // for alert webhook
const helmet = require('helmet');
const cookieParser = require('cookie-parser');

const PORT = process.env.PORT || 3000;
const REDIS_URL = process.env.REDIS_URL || null; // set to redis://... to enable
const ALERT_WEBHOOK = process.env.ALERT_WEBHOOK || null; // optional webhook for high-risk events

// Basic in-memory store for fingerprint history (demo only) - replace with DB in prod
const userHistoryStore = new Map(); // key = userId (or email), value = { ips: Set, devices: Set, timestamps: [] }
const globalIPBlacklist = new Set(['203.0.113.45']); // example blacklisted IP
const emailDomainBlacklist = new Set(['fraudmail.com']);

// Create Redis client if URL provided
let redisClient = null;
if (REDIS_URL) {
  redisClient = redis.createClient({ url: REDIS_URL });
  redisClient.connect().catch(err => {
    console.error('Redis connect failed:', err);
    redisClient = null;
  });
}

// Rate limiter config (login endpoint example)
const createRateLimiter = (max, windowMs) => {
  if (redisClient) {
    return rateLimit({
      windowMs,
      max,
      standardHeaders: true,
      legacyHeaders: false,
      store: new RedisStore({
        sendCommand: (...args) => redisClient.sendCommand(args),
      }),
      keyGenerator: (req) => {
        // Use IP + user identifier (if present) to avoid attackers rotating IPs
        return req.ip + '::' + (req.body?.email || req.query?.email || 'anon');
      },
    });
  } else {
    // fallback memory limiter
    return rateLimit({
      windowMs,
      max,
      standardHeaders: true,
      legacyHeaders: false,
      keyGenerator: (req) => req.ip + '::' + (req.body?.email || req.query?.email || 'anon'),
    });
  }
};

// Basic fingerprint extraction
function makeFingerprint(req) {
  // Combine elements that are common and accessible server-side
  const ua = req.headers['user-agent'] || '';
  const ip = req.ip || req.connection?.remoteAddress || 'unknown';
  const acceptLang = req.headers['accept-language'] || '';
  const forwarded = req.headers['x-forwarded-for'] || '';
  const flash = req.headers['user-agent-platform'] || ''; // placeholder

  // Simple hash (not cryptographic here)
  const raw = [ua, ip, acceptLang, forwarded, flash].join('|');
  const hash = require('crypto').createHash('sha256').update(raw).digest('hex');
  return { hash, ua, ip, acceptLang, forwarded };
}

// Rule-based risk scoring function
function scoreRisk({ userId, email, ip, fingerprintHash, ua, payload }) {
  let score = 0;
  const reasons = [];

  // 1) IP blacklists
  if (globalIPBlacklist.has(ip)) {
    score += 50; reasons.push('ip_blacklist');
  }

  // 2) Email domain blacklist
  const domain = (email || '').split('@')[1]?.toLowerCase();
  if (domain && emailDomainBlacklist.has(domain)) {
    score += 40; reasons.push('email_domain_blacklist');
  }

  // 3) Geo mismatch: check geoip country vs claimed country (if provided)
  const geo = geoip.lookup(ip);
  const country = geo?.country || '??';
  if (payload?.declared_country && payload.declared_country !== country) {
    score += 20; reasons.push(`country_mismatch server:${country} declared:${payload.declared_country}`);
  }

  // 4) Velocity - many attempts from same userId or IP in short time
  const history = userHistoryStore.get(userId) || { ips: new Set(), devices: new Set(), timestamps: [] };
  const now = Date.now();
  const recentTimestamps = history.timestamps.filter(t => now - t < 10 * 60 * 1000); // 10min window
  if (recentTimestamps.length > 5) { score += 25; reasons.push('high_velocity'); }

  // 5) Device/IP churn - many different IPs/devices for the same user
  if (history.ips && history.ips.size > 3) { score += 15; reasons.push('ip_churn'); }
  if (history.devices && history.devices.size > 3) { score += 15; reasons.push('device_churn'); }

  // 6) Known risky UA patterns (simple heuristics)
  if (ua && /curl|wget|scrapy|bot|python-requests/i.test(ua)) {
    score += 10; reasons.push('suspicious_user_agent');
  }

  // 7) New account + high transaction amount
  if (payload?.account_age_days !== undefined && payload.account_age_days < 2 && payload?.amount && payload.amount > 200) {
    score += 30; reasons.push('new_account_large_amount');
  }

  // 8) Fingerprint mismatch with previous known device for same user
  if (history.devices && history.devices.size > 0 && !history.devices.has(fingerprintHash)) {
    score += 10; reasons.push('new_device_for_user');
  }

  // Normalize score
  if (score > 100) score = 100;

  return { score, reasons, country };
}

// Action decision based on risk score
function decideAction(risk) {
  // risk.score is 0..100
  if (risk.score >= 80) return { action: 'block', reason: 'high_risk' };
  if (risk.score >= 50) return { action: 'challenge', reason: 'require_2fa_or_captcha' };
  if (risk.score >= 30) return { action: 'step_up', reason: 'require_additional_verification' };
  return { action: 'allow', reason: 'low_risk' };
}

// Simple logging + optional webhook for high-risk
async function logEvent(type, details) {
  const entry = { ts: new Date().toISOString(), type, details };
  console.log('FRAUD_EVENT', JSON.stringify(entry));
  try {
    if (ALERT_WEBHOOK && details && details.risk && details.risk.score >= 50) {
      await fetch(ALERT_WEBHOOK, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(entry),
      });
    }
  } catch (err) {
    console.warn('failed to send alert webhook', err);
  }
}

// Express app
const app = express();
app.use(helmet());
app.set('trust proxy', true); // if behind load balancer
app.use(bodyParser.json());
app.use(cookieParser());

// Rate limiter for login route: 10 attempts per 10 minutes per ip+email (customizable)
const loginLimiter = createRateLimiter(10, 10 * 60 * 1000);
const transactionLimiter = createRateLimiter(20, 60 * 60 * 1000); // example for transaction endpoint

// Example /login endpoint
app.post('/login', loginLimiter, async (req, res) => {
  const { email } = req.body;
  const userId = (email || '').toLowerCase();
  const fp = makeFingerprint(req);
  const payload = {
    declared_country: req.body.declared_country,
    account_age_days: req.body.account_age_days,
  };

  // Score risk
  const risk = scoreRisk({
    userId,
    email,
    ip: fp.ip,
    fingerprintHash: fp.hash,
    ua: fp.ua,
    payload,
  });

  const decision = decideAction(risk);

  await logEvent('login_attempt', { userId, email, ip: fp.ip, fingerprint: fp.hash, risk, decision });

  // Update history store
  const hist = userHistoryStore.get(userId) || { ips: new Set(), devices: new Set(), timestamps: [] };
  hist.ips.add(fp.ip);
  hist.devices.add(fp.hash);
  hist.timestamps.push(Date.now());
  // Keep last 100 timestamps
  if (hist.timestamps.length > 100) hist.timestamps = hist.timestamps.slice(-100);
  userHistoryStore.set(userId, hist);

  // Respond based on decision
  if (decision.action === 'block') {
    return res.status(403).json({ status: 'blocked', reason: decision.reason });
  }
  if (decision.action === 'challenge') {
    // Return that frontend must show CAPTCHA or require 2FA
    return res.status(200).json({ status: 'challenge', challenge: '2fa_or_captcha', reason: decision.reason });
  }
  // Otherwise proceed with normal login flow (authenticate here)
  // NOTE: actual authentication (password check, bcrypt, etc) should happen AFTER or before scoring depending on design.
  return res.status(200).json({ status: 'ok', risk: risk.score, reason: 'proceed_with_auth' });
});

// Example /transaction endpoint (higher-security)
app.post('/transaction', transactionLimiter, async (req, res) => {
  // Expect payload: { userId, amount, account_age_days, declared_country, email }
  const { userId, amount, account_age_days, declared_country, email } = req.body;
  if (!userId) return res.status(400).json({ error: 'missing userId' });

  const fp = makeFingerprint(req);
  const risk = scoreRisk({
    userId,
    email,
    ip: fp.ip,
    fingerprintHash: fp.hash,
    ua: fp.ua,
    payload: { account_age_days, amount, declared_country },
  });
  const decision = decideAction(risk);
  await logEvent('transaction_attempt', { userId, amount, ip: fp.ip, risk, decision });

  // Implement step-up behavior
  if (decision.action === 'block') {
    return res.status(403).json({ status: 'blocked', reason: decision.reason });
  }
  if (decision.action === 'challenge' || decision.action === 'step_up') {
    // e.g., require 2FA code, or delay transaction until review
    return res.status(200).json({ status: 'challenge', required: ['2fa', 'manual_review'], risk: risk.score });
  }

  // If allowed: perform transaction (placeholder)
  // TODO: plug actual payment/transfer API and guard with two-party auth
  return res.status(200).json({ status: 'approved', risk: risk.score });
});

// Admin endpoint to fetch user history (demo only)
app.get('/admin/history/:userId', (req, res) => {
  const hist = userHistoryStore.get(req.params.userId) || { ips: [], devices: [], timestamps: [] };
  res.json({
    ips: Array.from(hist.ips || []),
    devices: Array.from(hist.devices || []),
    recentAttempts: hist.timestamps || [],
  });
});

// Basic health
app.get('/health', (req, res) => res.json({ ok: true }));

app.listen(PORT, () => {
  console.log(`Fraud protection demo running on port ${PORT}`);
  if (!redisClient) console.log('Redis not configured — using in-memory rate limiting fallback');
});



https://5e514gxfo--1nnj5h009phdp0u.hop.clickbank.net/?tid=G_N3CJ3VTZ5S-

/**
 * fraud-protect-app.js
 * Minimal layered fraud protection example (Express)
 *
 * Features:
 * - Rate limiter with Redis fallback
 * - Simple device/IP fingerprint
 * - Risk scoring engine (rules)
 * - Challenge escalation: allow / require captcha or 2FA or block
 * - Event logging and webhook alert
 */

const express = require('express');
const rateLimit = require('express-rate-limit');
const RedisStore = require('rate-limit-redis');
const redis = require('redis');
const geoip = require('geoip-lite');
const bodyParser = require('body-parser');
const fetch = require('node-fetch'); // for alert webhook
const helmet = require('helmet');
const cookieParser = require('cookie-parser');

const PORT = process.env.PORT || 3000;
const REDIS_URL = process.env.REDIS_URL || null; // set to redis://... to enable
const ALERT_WEBHOOK = process.env.ALERT_WEBHOOK || null; // optional webhook for high-risk events

// Basic in-memory store for fingerprint history (demo only) - replace with DB in prod
const userHistoryStore = new Map(); // key = userId (or email), value = { ips: Set, devices: Set, timestamps: [] }
const globalIPBlacklist = new Set(['203.0.113.45']); // example blacklisted IP
const emailDomainBlacklist = new Set(['fraudmail.com']);

// Create Redis client if URL provided
let redisClient = null;
if (REDIS_URL) {
  redisClient = redis.createClient({ url: REDIS_URL });
  redisClient.connect().catch(err => {
    console.error('Redis connect failed:', err);
    redisClient = null;
  });
}

// Rate limiter config (login endpoint example)
const createRateLimiter = (max, windowMs) => {
  if (redisClient) {
    return rateLimit({
      windowMs,
      max,
      standardHeaders: true,
      legacyHeaders: false,
      store: new RedisStore({
        sendCommand: (...args) => redisClient.sendCommand(args),
      }),
      keyGenerator: (req) => {
        // Use IP + user identifier (if present) to avoid attackers rotating IPs
        return req.ip + '::' + (req.body?.email || req.query?.email || 'anon');
      },
    });
  } else {
    // fallback memory limiter
    return rateLimit({
      windowMs,
      max,
      standardHeaders: true,
      legacyHeaders: false,
      keyGenerator: (req) => req.ip + '::' + (req.body?.email || req.query?.email || 'anon'),
    });
  }
};

// Basic fingerprint extraction
function makeFingerprint(req) {
  // Combine elements that are common and accessible server-side
  const ua = req.headers['user-agent'] || '';
  const ip = req.ip || req.connection?.remoteAddress || 'unknown';
  const acceptLang = req.headers['accept-language'] || '';
  const forwarded = req.headers['x-forwarded-for'] || '';
  const flash = req.headers['user-agent-platform'] || ''; // placeholder

  // Simple hash (not cryptographic here)
  const raw = [ua, ip, acceptLang, forwarded, flash].join('|');
  const hash = require('crypto').createHash('sha256').update(raw).digest('hex');
  return { hash, ua, ip, acceptLang, forwarded };
}

// Rule-based risk scoring function
function scoreRisk({ userId, email, ip, fingerprintHash, ua, payload }) {
  let score = 0;
  const reasons = [];

  // 1) IP blacklists
  if (globalIPBlacklist.has(ip)) {
    score += 50; reasons.push('ip_blacklist');
  }

  // 2) Email domain blacklist
  const domain = (email || '').split('@')[1]?.toLowerCase();
  if (domain && emailDomainBlacklist.has(domain)) {
    score += 40; reasons.push('email_domain_blacklist');
  }

  // 3) Geo mismatch: check geoip country vs claimed country (if provided)
  const geo = geoip.lookup(ip);
  const country = geo?.country || '??';
  if (payload?.declared_country && payload.declared_country !== country) {
    score += 20; reasons.push(`country_mismatch server:${country} declared:${payload.declared_country}`);
  }

  // 4) Velocity - many attempts from same userId or IP in short time
  const history = userHistoryStore.get(userId) || { ips: new Set(), devices: new Set(), timestamps: [] };
  const now = Date.now();
  const recentTimestamps = history.timestamps.filter(t => now - t < 10 * 60 * 1000); // 10min window
  if (recentTimestamps.length > 5) { score += 25; reasons.push('high_velocity'); }

  // 5) Device/IP churn - many different IPs/devices for the same user
  if (history.ips && history.ips.size > 3) { score += 15; reasons.push('ip_churn'); }
  if (history.devices && history.devices.size > 3) { score += 15; reasons.push('device_churn'); }

  // 6) Known risky UA patterns (simple heuristics)
  if (ua && /curl|wget|scrapy|bot|python-requests/i.test(ua)) {
    score += 10; reasons.push('suspicious_user_agent');
  }

  // 7) New account + high transaction amount
  if (payload?.account_age_days !== undefined && payload.account_age_days < 2 && payload?.amount && payload.amount > 200) {
    score += 30; reasons.push('new_account_large_amount');
  }

  // 8) Fingerprint mismatch with previous known device for same user
  if (history.devices && history.devices.size > 0 && !history.devices.has(fingerprintHash)) {
    score += 10; reasons.push('new_device_for_user');
  }

  // Normalize score
  if (score > 100) score = 100;

  return { score, reasons, country };
}

// Action decision based on risk score
function decideAction(risk) {
  // risk.score is 0..100
  if (risk.score >= 80) return { action: 'block', reason: 'high_risk' };
  if (risk.score >= 50) return { action: 'challenge', reason: 'require_2fa_or_captcha' };
  if (risk.score >= 30) return { action: 'step_up', reason: 'require_additional_verification' };
  return { action: 'allow', reason: 'low_risk' };
}

// Simple logging + optional webhook for high-risk
async function logEvent(type, details) {
  const entry = { ts: new Date().toISOString(), type, details };
  console.log('FRAUD_EVENT', JSON.stringify(entry));
  try {
    if (ALERT_WEBHOOK && details && details.risk && details.risk.score >= 50) {
      await fetch(ALERT_WEBHOOK, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(entry),
      });
    }
  } catch (err) {
    console.warn('failed to send alert webhook', err);
  }
}

// Express app
const app = express();
app.use(helmet());
app.set('trust proxy', true); // if behind load balancer
app.use(bodyParser.json());
app.use(cookieParser());

// Rate limiter for login route: 10 attempts per 10 minutes per ip+email (customizable)
const loginLimiter = createRateLimiter(10, 10 * 60 * 1000);
const transactionLimiter = createRateLimiter(20, 60 * 60 * 1000); // example for transaction endpoint

// Example /login endpoint
app.post('/login', loginLimiter, async (req, res) => {
  const { email } = req.body;
  const userId = (email || '').toLowerCase();
  const fp = makeFingerprint(req);
  const payload = {
    declared_country: req.body.declared_country,
    account_age_days: req.body.account_age_days,
  };

  // Score risk
  const risk = scoreRisk({
    userId,
    email,
    ip: fp.ip,
    fingerprintHash: fp.hash,
    ua: fp.ua,
    payload,
  });

  const decision = decideAction(risk);

  await logEvent('login_attempt', { userId, email, ip: fp.ip, fingerprint: fp.hash, risk, decision });

  // Update history store
  const hist = userHistoryStore.get(userId) || { ips: new Set(), devices: new Set(), timestamps: [] };
  hist.ips.add(fp.ip);
  hist.devices.add(fp.hash);
  hist.timestamps.push(Date.now());
  // Keep last 100 timestamps
  if (hist.timestamps.length > 100) hist.timestamps = hist.timestamps.slice(-100);
  userHistoryStore.set(userId, hist);

  // Respond based on decision
  if (decision.action === 'block') {
    return res.status(403).json({ status: 'blocked', reason: decision.reason });
  }
  if (decision.action === 'challenge') {
    // Return that frontend must show CAPTCHA or require 2FA
    return res.status(200).json({ status: 'challenge', challenge: '2fa_or_captcha', reason: decision.reason });
  }
  // Otherwise proceed with normal login flow (authenticate here)
  // NOTE: actual authentication (password check, bcrypt, etc) should happen AFTER or before scoring depending on design.
  return res.status(200).json({ status: 'ok', risk: risk.score, reason: 'proceed_with_auth' });
});

// Example /transaction endpoint (higher-security)
app.post('/transaction', transactionLimiter, async (req, res) => {
  // Expect payload: { userId, amount, account_age_days, declared_country, email }
  const { userId, amount, account_age_days, declared_country, email } = req.body;
  if (!userId) return res.status(400).json({ error: 'missing userId' });

  const fp = makeFingerprint(req);
  const risk = scoreRisk({
    userId,
    email,
    ip: fp.ip,
    fingerprintHash: fp.hash,
    ua: fp.ua,
    payload: { account_age_days, amount, declared_country },
  });
  const decision = decideAction(risk);
  await logEvent('transaction_attempt', { userId, amount, ip: fp.ip, risk, decision });

  // Implement step-up behavior
  if (decision.action === 'block') {
    return res.status(403).json({ status: 'blocked', reason: decision.reason });
  }
  if (decision.action === 'challenge' || decision.action === 'step_up') {
    // e.g., require 2FA code, or delay transaction until review
    return res.status(200).json({ status: 'challenge', required: ['2fa', 'manual_review'], risk: risk.score });
  }

  // If allowed: perform transaction (placeholder)
  // TODO: plug actual payment/transfer API and guard with two-party auth
  return res.status(200).json({ status: 'approved', risk: risk.score });
});

// Admin endpoint to fetch user history (demo only)
app.get('/admin/history/:userId', (req, res) => {
  const hist = userHistoryStore.get(req.params.userId) || { ips: [], devices: [], timestamps: [] };
  res.json({
    ips: Array.from(hist.ips || []),
    devices: Array.from(hist.devices || []),
    recentAttempts: hist.timestamps || [],
  });
});

// Basic health
app.get('/health', (req, res) => res.json({ ok: true }));

app.listen(PORT, () => {
  console.log(`Fraud protection demo running on port ${PORT}`);
  if (!redisClient) console.log('Redis not configured — using in-memory rate limiting fallback');
});

https://01674zmsgp-q4p8esja5ykhpet.hop.clickbank.net/?cbpage=40-Percent-Off-Yearly

https://22e6empjmu-1tdmc0bjftzlzeq.hop.clickbank.net

https://roothealthmyhealthmatters.wordpress.com/2023/01/06/what-parasites-are-living-in-the-gut/
https://badbackadvise.blogspot.com/2019/09/bad-back-pain-advise.html
https://getglucotrust.com?shield=dee7a0ttgxbphve1sqem1q-m7o

https://b6f4a2uipj4t6q8ta5x1sl3wcw.hop.clickbank.net/?&traffic_source=pinterest&traffic_type=organic

https://f13d8kpojs7akjnb1hii4kw417.hop.clickbank.net.uk/?tid=GR9D48BY6E9/bluezy32/rose2white

https://fd5145ujqm3zbu2yslz6wj2mkc.hop.clickbank.net/?&traffic_source=pinterest&traffic_type=organic&extclid=Tinyurl.com-245gkxpu

https://2948bnsoisy2qfs4pllzwmar95.hop.clickbank.net/?tid=G602LQM2ZQE/bluezy32/rose2white

https://myhealthmatters.life.blogspot.com/2023/01/what-is-best-food-for-gut.html/G-P6JWWRY34Q
https://5e514gxfo--1nnj5h009phdp0u.hop.clickbank.net/?tid=G_N3CJ3VTZ5S

https://658bdavqqs9r9p1ae30yod2k5p.hop.clickbank.net/?&traffic_source=pinterest&traffic_type=organic

https://clearobstacles.blogspot.com
https://67d63gsoluyevslvo3vafl5s1k.hop.clickbank.net/?cbpage=customplan&tid=G8Q388G9K2G

https://2c86fautrwdual09uhxruc2wbo.hop.clickbank.net/rose2white/bluezy32
https://daa0fyjjvgn9-niiqh0sz7exbz.hop.clickbank.net/?&extclid=G-5LR98KNFY0
https://hop.clickbank.net/?vendor=livpure&affiliate=bluezy32&lid=1&tid=G-GV0426PE8H - /**
 * fraud-protect-app.js
 * Minimal layered fraud protection example (Express)
 *
 * Features:
 * - Rate limiter with Redis fallback
 * - Simple device/IP fingerprint
 * - Risk scoring engine (rules)
 * - Challenge escalation: allow / require captcha or 2FA or block
 * - Event logging and webhook alert
 */

const express = require('express');
const rateLimit = require('express-rate-limit');
const RedisStore = require('rate-limit-redis');
const redis = require('redis');
const geoip = require('geoip-lite');
const bodyParser = require('body-parser');
const fetch = require('node-fetch'); // for alert webhook
const helmet = require('helmet');
const cookieParser = require('cookie-parser');

const PORT = process.env.PORT || 3000;
const REDIS_URL = process.env.REDIS_URL || null; // set to redis://... to enable
const ALERT_WEBHOOK = process.env.ALERT_WEBHOOK || null; // optional webhook for high-risk events

// Basic in-memory store for fingerprint history (demo only) - replace with DB in prod
const userHistoryStore = new Map(); // key = userId (or email), value = { ips: Set, devices: Set, timestamps: [] }
const globalIPBlacklist = new Set(['203.0.113.45']); // example blacklisted IP
const emailDomainBlacklist = new Set(['fraudmail.com']);

// Create Redis client if URL provided
let redisClient = null;
if (REDIS_URL) {
  redisClient = redis.createClient({ url: REDIS_URL });
  redisClient.connect().catch(err => {
    console.error('Redis connect failed:', err);
    redisClient = null;
  });
}

// Rate limiter config (login endpoint example)
const createRateLimiter = (max, windowMs) => {
  if (redisClient) {
    return rateLimit({
      windowMs,
      max,
      standardHeaders: true,
      legacyHeaders: false,
      store: new RedisStore({
        sendCommand: (...args) => redisClient.sendCommand(args),
      }),
      keyGenerator: (req) => {
        // Use IP + user identifier (if present) to avoid attackers rotating IPs
        return req.ip + '::' + (req.body?.email || req.query?.email || 'anon');
      },
    });
  } else {
    // fallback memory limiter
    return rateLimit({
      windowMs,
      max,
      standardHeaders: true,
      legacyHeaders: false,
      keyGenerator: (req) => req.ip + '::' + (req.body?.email || req.query?.email || 'anon'),
    });
  }
};

// Basic fingerprint extraction
function makeFingerprint(req) {
  // Combine elements that are common and accessible server-side
  const ua = req.headers['user-agent'] || '';
  const ip = req.ip || req.connection?.remoteAddress || 'unknown';
  const acceptLang = req.headers['accept-language'] || '';
  const forwarded = req.headers['x-forwarded-for'] || '';
  const flash = req.headers['user-agent-platform'] || ''; // placeholder

  // Simple hash (not cryptographic here)
  const raw = [ua, ip, acceptLang, forwarded, flash].join('|');
  const hash = require('crypto').createHash('sha256').update(raw).digest('hex');
  return { hash, ua, ip, acceptLang, forwarded };
}

// Rule-based risk scoring function
function scoreRisk({ userId, email, ip, fingerprintHash, ua, payload }) {
  let score = 0;
  const reasons = [];

  // 1) IP blacklists
  if (globalIPBlacklist.has(ip)) {
    score += 50; reasons.push('ip_blacklist');
  }

  // 2) Email domain blacklist
  const domain = (email || '').split('@')[1]?.toLowerCase();
  if (domain && emailDomainBlacklist.has(domain)) {
    score += 40; reasons.push('email_domain_blacklist');
  }

  // 3) Geo mismatch: check geoip country vs claimed country (if provided)
  const geo = geoip.lookup(ip);
  const country = geo?.country || '??';
  if (payload?.declared_country && payload.declared_country !== country) {
    score += 20; reasons.push(`country_mismatch server:${country} declared:${payload.declared_country}`);
  }

  // 4) Velocity - many attempts from same userId or IP in short time
  const history = userHistoryStore.get(userId) || { ips: new Set(), devices: new Set(), timestamps: [] };
  const now = Date.now();
  const recentTimestamps = history.timestamps.filter(t => now - t < 10 * 60 * 1000); // 10min window
  if (recentTimestamps.length > 5) { score += 25; reasons.push('high_velocity'); }

  // 5) Device/IP churn - many different IPs/devices for the same user
  if (history.ips && history.ips.size > 3) { score += 15; reasons.push('ip_churn'); }
  if (history.devices && history.devices.size > 3) { score += 15; reasons.push('device_churn'); }

  // 6) Known risky UA patterns (simple heuristics)
  if (ua && /curl|wget|scrapy|bot|python-requests/i.test(ua)) {
    score += 10; reasons.push('suspicious_user_agent');
  }

  // 7) New account + high transaction amount
  if (payload?.account_age_days !== undefined && payload.account_age_days < 2 && payload?.amount && payload.amount > 200) {
    score += 30; reasons.push('new_account_large_amount');
  }

  // 8) Fingerprint mismatch with previous known device for same user
  if (history.devices && history.devices.size > 0 && !history.devices.has(fingerprintHash)) {
    score += 10; reasons.push('new_device_for_user');
  }

  // Normalize score
  if (score > 100) score = 100;

  return { score, reasons, country };
}

// Action decision based on risk score
function decideAction(risk) {
  // risk.score is 0..100
  if (risk.score >= 80) return { action: 'block', reason: 'high_risk' };
  if (risk.score >= 50) return { action: 'challenge', reason: 'require_2fa_or_captcha' };
  if (risk.score >= 30) return { action: 'step_up', reason: 'require_additional_verification' };
  return { action: 'allow', reason: 'low_risk' };
}

// Simple logging + optional webhook for high-risk
async function logEvent(type, details) {
  const entry = { ts: new Date().toISOString(), type, details };
  console.log('FRAUD_EVENT', JSON.stringify(entry));
  try {
    if (ALERT_WEBHOOK && details && details.risk && details.risk.score >= 50) {
      await fetch(ALERT_WEBHOOK, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(entry),
      });
    }
  } catch (err) {
    console.warn('failed to send alert webhook', err);
  }
}

// Express app
const app = express();
app.use(helmet());
app.set('trust proxy', true); // if behind load balancer
app.use(bodyParser.json());
app.use(cookieParser());

// Rate limiter for login route: 10 attempts per 10 minutes per ip+email (customizable)
const loginLimiter = createRateLimiter(10, 10 * 60 * 1000);
const transactionLimiter = createRateLimiter(20, 60 * 60 * 1000); // example for transaction endpoint

// Example /login endpoint
app.post('/login', loginLimiter, async (req, res) => {
  const { email } = req.body;
  const userId = (email || '').toLowerCase();
  const fp = makeFingerprint(req);
  const payload = {
    declared_country: req.body.declared_country,
    account_age_days: req.body.account_age_days,
  };

  // Score risk
  const risk = scoreRisk({
    userId,
    email,
    ip: fp.ip,
    fingerprintHash: fp.hash,
    ua: fp.ua,
    payload,
  });

  const decision = decideAction(risk);

  await logEvent('login_attempt', { userId, email, ip: fp.ip, fingerprint: fp.hash, risk, decision });

  // Update history store
  const hist = userHistoryStore.get(userId) || { ips: new Set(), devices: new Set(), timestamps: [] };
  hist.ips.add(fp.ip);
  hist.devices.add(fp.hash);
  hist.timestamps.push(Date.now());
  // Keep last 100 timestamps
  if (hist.timestamps.length > 100) hist.timestamps = hist.timestamps.slice(-100);
  userHistoryStore.set(userId, hist);

  // Respond based on decision
  if (decision.action === 'block') {
    return res.status(403).json({ status: 'blocked', reason: decision.reason });
  }
  if (decision.action === 'challenge') {
    // Return that frontend must show CAPTCHA or require 2FA
    return res.status(200).json({ status: 'challenge', challenge: '2fa_or_captcha', reason: decision.reason });
  }
  // Otherwise proceed with normal login flow (authenticate here)
  // NOTE: actual authentication (password check, bcrypt, etc) should happen AFTER or before scoring depending on design.
  return res.status(200).json({ status: 'ok', risk: risk.score, reason: 'proceed_with_auth' });
});

// Example /transaction endpoint (higher-security)
app.post('/transaction', transactionLimiter, async (req, res) => {
  // Expect payload: { userId, amount, account_age_days, declared_country, email }
  const { userId, amount, account_age_days, declared_country, email } = req.body;
  if (!userId) return res.status(400).json({ error: 'missing userId' });

  const fp = makeFingerprint(req);
  const risk = scoreRisk({
    userId,
    email,
    ip: fp.ip,
    fingerprintHash: fp.hash,
    ua: fp.ua,
    payload: { account_age_days, amount, declared_country },
  });
  const decision = decideAction(risk);
  await logEvent('transaction_attempt', { userId, amount, ip: fp.ip, risk, decision });

  // Implement step-up behavior
  if (decision.action === 'block') {
    return res.status(403).json({ status: 'blocked', reason: decision.reason });
  }
  if (decision.action === 'challenge' || decision.action === 'step_up') {
    // e.g., require 2FA code, or delay transaction until review
    return res.status(200).json({ status: 'challenge', required: ['2fa', 'manual_review'], risk: risk.score });
  }

  // If allowed: perform transaction (placeholder)
  // TODO: plug actual payment/transfer API and guard with two-party auth
  return res.status(200).json({ status: 'approved', risk: risk.score });
});

// Admin endpoint to fetch user history (demo only)
app.get('/admin/history/:userId', (req, res) => {
  const hist = userHistoryStore.get(req.params.userId) || { ips: [], devices: [], timestamps: [] };
  res.json({
    ips: Array.from(hist.ips || []),
    devices: Array.from(hist.devices || []),
    recentAttempts: hist.timestamps || [],
  });
});

// Basic health
app.get('/health', (req, res) => res.json({ ok: true }));

app.listen(PORT, () => {
  console.log(`Fraud protection demo running on port ${PORT}`);
  if (!redisClient) console.log('Redis not configured — using in-memory rate limiting fallback');
});
https://480a5n0pko-2jpuksl0qp7azex.hop.clickbank.net

https://d9014evcrsz3jqq2v0u6zexhfg.hop.clickbank.net/?tid=GQ8DZ25YVT1/rose2white/bluezy32
https://www.docs.google.com/document/d/e/2PACX-1vSMspzcQERxa0tm-EUJzNTev6cLKx3gQmpB2TGvTCWI_NAVu42tm0bHHcNuNTpHD9YOYV_VNjJJe9Ds/pub

https://healthmealplans8@blogspot.com
https://09342gxett8ejdu7ichmrl6r6p.hop.clickbank.net
https://b6f4a2uipj4t6q8ta5x1sl3wcw.hop.clickbank.net/?&traffic_source=pinterest&traffic_type=organic
https://d7827gwjpsz2qsu-neav2864zf.hop.clickbank.net/?tid=G_CBZ4PYWLEK/rose2white/bluezy32
https://docs.google.com/document/d/e/2PACX-1vS8qzgVncHyQzfHcNf408tVXdunO8nx4KRUd0Zn0McQ7QnD6DLuPGtnyQpOvcydEs1LPVCyyesvOM1b/pub
https://rwww.oothealth.myhealthmatters.life
https://1e4c3dsrupbfvdsopjegw-q94l.hop.clickbank.net/?tid=G_32SN8ZTD6X/rose2white/bluezy32
https://sup.myhealthmatters.life/blogs/news

https://myhealthmatterslife3.blogspot.com/G-C0ZP3G88BT
https://roothealthmyhealthmatters.wordpress.com/2023/01/06/what-parasites-are-living-in-the-gut/

https://178f4nqeks6fjllaqjv8r72wbw.hop.clickbank.net

https://www.bloodsugar.myhealthmatters.life
https://67d63gsoluyevslvo3vafl5s1k.hop.clickbank.net/?cbpage=customplan&tid=G8Q388G9K2G

https://178f4nqeks6fjllaqjv8r72wbw.hop.clickbank.net
https://67d63gsoluyevslvo3vafl5s1k.hop.clickbank.net/?cbpage=customplan&tid=G8Q388G9K2G
https://weightlossdietplans.net/?shield=4670dqpnn057seinm3mg1o2w5y
https://www.mind.myhealthmatters.life
https://d15649mkoq6-6s2rbrh2dt7tao.hop.clickbank.net 
https://a41a8btusbkcngexu20j-8vcno.hop.clickbank.net   https://tinyurl.com/24zjycq4
https://tinyurl.com/2xh46dv5

https://tinyurl.com/28crywk8       
https://www.healthymealplans8.blogspot.com/2024/10/healthy-meal-planning-guide-healthy.html?zx=5810ac80627fe74f    
https://tinyurl.com/28crywk8



https://01674zmsgp-q4p8esja5ykhpet.hop.clickbank.net/?cbpage=40-Percent-Off-Yearly
https://22e6empjmu-1tdmc0bjftzlzeq.hop.clickbank.net

https://roothealthmyhealthmatters.wordpress.com/2023/01/06/what-parasites-are-living-in-the-gut/
https://178f4nqeks6fjllaqjv8r72wbw.hop.clickbank.net
https://badbackadvise.blogspot.com/2019/09/bad-back-pain-advise.html/G-8STYNX2VCY
https://getglucotrust.com?shield=dee7a0ttgxbphve1sqem1q-m7o

https://d5821aqtrpq8qej32aycmhiw3e.hop.clickbank.net

https://7ca4czklwdk1rr82slxbi8pz9d.hop.clickbank.net

https://b6f4a2uipj4t6q8ta5x1sl3wcw.hop.clickbank.net/?&traffic_source=pinterest&traffic_type=organic


https://4be9damjtxzzdp87w42gtnoo2o.hop.clickbank.net
https://5e514gxfo--1nnj5h009phdp0u.hop.clickbank.net/?tid=G_N3CJ3VTZ5S
https://https://a0cfa20iuv10eq33qzgbjk2jdm.hop.clickbank.net/?&extclid=G-1Y1K28SDRY
https://f13d8kpojs7akjnb1hii4kw417.hop.clickbank.net.uk/?tid=GR9D48BY6E9/bluezy32/rose2white

https://fd5145ujqm3zbu2yslz6wj2mkc.hop.clickbank.net/?&traffic_source=pinterest&traffic_type=organic&extclid=Tinyurl.com-245gkxpu
https://-8vcno.hop.clickbank.net

https://fee0bh0lft57skl200qcs8tduu.hop.clickbank.net

https://2948bnsoisy2qfs4pllzwmar95.hop.clickbank.net/?tid=G602LQM2ZQE/bluezy32/rose2white

/**
 * fraud-protect-app.js
 * Minimal layered fraud protection example (Express)
 *
 * Features:
 * - Rate limiter with Redis fallback
 * - Simple device/IP fingerprint
 * - Risk scoring engine (rules)
 * - Challenge escalation: allow / require captcha or 2FA or block
 * - Event logging and webhook alert
 */

const express = require('express');
const rateLimit = require('express-rate-limit');
const RedisStore = require('rate-limit-redis');
const redis = require('redis');
const geoip = require('geoip-lite');
const bodyParser = require('body-parser');
const fetch = require('node-fetch'); // for alert webhook
const helmet = require('helmet');
const cookieParser = require('cookie-parser');

const PORT = process.env.PORT || 3000;
const REDIS_URL = process.env.REDIS_URL || null; // set to redis://... to enable
const ALERT_WEBHOOK = process.env.ALERT_WEBHOOK || null; // optional webhook for high-risk events

// Basic in-memory store for fingerprint history (demo only) - replace with DB in prod
const userHistoryStore = new Map(); // key = userId (or email), value = { ips: Set, devices: Set, timestamps: [] }
const globalIPBlacklist = new Set(['203.0.113.45']); // example blacklisted IP
const emailDomainBlacklist = new Set(['fraudmail.com']);

// Create Redis client if URL provided
let redisClient = null;
if (REDIS_URL) {
  redisClient = redis.createClient({ url: REDIS_URL });
  redisClient.connect().catch(err => {
    console.error('Redis connect failed:', err);
    redisClient = null;
  });
}

// Rate limiter config (login endpoint example)
const createRateLimiter = (max, windowMs) => {
  if (redisClient) {
    return rateLimit({
      windowMs,
      max,
      standardHeaders: true,
      legacyHeaders: false,
      store: new RedisStore({
        sendCommand: (...args) => redisClient.sendCommand(args),
      }),
      keyGenerator: (req) => {
        // Use IP + user identifier (if present) to avoid attackers rotating IPs
        return req.ip + '::' + (req.body?.email || req.query?.email || 'anon');
      },
    });
  } else {
    // fallback memory limiter
    return rateLimit({
      windowMs,
      max,
      standardHeaders: true,
      legacyHeaders: false,
      keyGenerator: (req) => req.ip + '::' + (req.body?.email || req.query?.email || 'anon'),
    });
  }
};

// Basic fingerprint extraction
function makeFingerprint(req) {
  // Combine elements that are common and accessible server-side
  const ua = req.headers['user-agent'] || '';
  const ip = req.ip || req.connection?.remoteAddress || 'unknown';
  const acceptLang = req.headers['accept-language'] || '';
  const forwarded = req.headers['x-forwarded-for'] || '';
  const flash = req.headers['user-agent-platform'] || ''; // placeholder

  // Simple hash (not cryptographic here)
  const raw = [ua, ip, acceptLang, forwarded, flash].join('|');
  const hash = require('crypto').createHash('sha256').update(raw).digest('hex');
  return { hash, ua, ip, acceptLang, forwarded };
}

// Rule-based risk scoring function
function scoreRisk({ userId, email, ip, fingerprintHash, ua, payload }) {
  let score = 0;
  const reasons = [];

  // 1) IP blacklists
  if (globalIPBlacklist.has(ip)) {
    score += 50; reasons.push('ip_blacklist');
  }

  // 2) Email domain blacklist
  const domain = (email || '').split('@')[1]?.toLowerCase();
  if (domain && emailDomainBlacklist.has(domain)) {
    score += 40; reasons.push('email_domain_blacklist');
  }

  // 3) Geo mismatch: check geoip country vs claimed country (if provided)
  const geo = geoip.lookup(ip);
  const country = geo?.country || '??';
  if (payload?.declared_country && payload.declared_country !== country) {
    score += 20; reasons.push(`country_mismatch server:${country} declared:${payload.declared_country}`);
  }

  // 4) Velocity - many attempts from same userId or IP in short time
  const history = userHistoryStore.get(userId) || { ips: new Set(), devices: new Set(), timestamps: [] };
  const now = Date.now();
  const recentTimestamps = history.timestamps.filter(t => now - t < 10 * 60 * 1000); // 10min window
  if (recentTimestamps.length > 5) { score += 25; reasons.push('high_velocity'); }

  // 5) Device/IP churn - many different IPs/devices for the same user
  if (history.ips && history.ips.size > 3) { score += 15; reasons.push('ip_churn'); }
  if (history.devices && history.devices.size > 3) { score += 15; reasons.push('device_churn'); }

  // 6) Known risky UA patterns (simple heuristics)
  if (ua && /curl|wget|scrapy|bot|python-requests/i.test(ua)) {
    score += 10; reasons.push('suspicious_user_agent');
  }

  // 7) New account + high transaction amount
  if (payload?.account_age_days !== undefined && payload.account_age_days < 2 && payload?.amount && payload.amount > 200) {
    score += 30; reasons.push('new_account_large_amount');
  }

  // 8) Fingerprint mismatch with previous known device for same user
  if (history.devices && history.devices.size > 0 && !history.devices.has(fingerprintHash)) {
    score += 10; reasons.push('new_device_for_user');
  }

  // Normalize score
  if (score > 100) score = 100;

  return { score, reasons, country };
}

// Action decision based on risk score
function decideAction(risk) {
  // risk.score is 0..100
  if (risk.score >= 80) return { action: 'block', reason: 'high_risk' };
  if (risk.score >= 50) return { action: 'challenge', reason: 'require_2fa_or_captcha' };
  if (risk.score >= 30) return { action: 'step_up', reason: 'require_additional_verification' };
  return { action: 'allow', reason: 'low_risk' };
}

// Simple logging + optional webhook for high-risk
async function logEvent(type, details) {
  const entry = { ts: new Date().toISOString(), type, details };
  console.log('FRAUD_EVENT', JSON.stringify(entry));
  try {
    if (ALERT_WEBHOOK && details && details.risk && details.risk.score >= 50) {
      await fetch(ALERT_WEBHOOK, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(entry),
      });
    }
  } catch (err) {
    console.warn('failed to send alert webhook', err);
  }
}

// Express app
const app = express();
app.use(helmet());
app.set('trust proxy', true); // if behind load balancer
app.use(bodyParser.json());
app.use(cookieParser());

// Rate limiter for login route: 10 attempts per 10 minutes per ip+email (customizable)
const loginLimiter = createRateLimiter(10, 10 * 60 * 1000);
const transactionLimiter = createRateLimiter(20, 60 * 60 * 1000); // example for transaction endpoint

// Example /login endpoint
app.post('/login', loginLimiter, async (req, res) => {
  const { email } = req.body;
  const userId = (email || '').toLowerCase();
  const fp = makeFingerprint(req);
  const payload = {
    declared_country: req.body.declared_country,
    account_age_days: req.body.account_age_days,
  };

  // Score risk
  const risk = scoreRisk({
    userId,
    email,
    ip: fp.ip,
    fingerprintHash: fp.hash,
    ua: fp.ua,
    payload,
  });

  const decision = decideAction(risk);

  await logEvent('login_attempt', { userId, email, ip: fp.ip, fingerprint: fp.hash, risk, decision });

  // Update history store
  const hist = userHistoryStore.get(userId) || { ips: new Set(), devices: new Set(), timestamps: [] };
  hist.ips.add(fp.ip);
  hist.devices.add(fp.hash);
  hist.timestamps.push(Date.now());
  // Keep last 100 timestamps
  if (hist.timestamps.length > 100) hist.timestamps = hist.timestamps.slice(-100);
  userHistoryStore.set(userId, hist);

  // Respond based on decision
  if (decision.action === 'block') {
    return res.status(403).json({ status: 'blocked', reason: decision.reason });
  }
  if (decision.action === 'challenge') {
    // Return that frontend must show CAPTCHA or require 2FA
    return res.status(200).json({ status: 'challenge', challenge: '2fa_or_captcha', reason: decision.reason });
  }
  // Otherwise proceed with normal login flow (authenticate here)
  // NOTE: actual authentication (password check, bcrypt, etc) should happen AFTER or before scoring depending on design.
  return res.status(200).json({ status: 'ok', risk: risk.score, reason: 'proceed_with_auth' });
});

// Example /transaction endpoint (higher-security)
app.post('/transaction', transactionLimiter, async (req, res) => {
  // Expect payload: { userId, amount, account_age_days, declared_country, email }
  const { userId, amount, account_age_days, declared_country, email } = req.body;
  if (!userId) return res.status(400).json({ error: 'missing userId' });

  const fp = makeFingerprint(req);
  const risk = scoreRisk({
    userId,
    email,
    ip: fp.ip,
    fingerprintHash: fp.hash,
    ua: fp.ua,
    payload: { account_age_days, amount, declared_country },
  });
  const decision = decideAction(risk);
  await logEvent('transaction_attempt', { userId, amount, ip: fp.ip, risk, decision });

  // Implement step-up behavior
  if (decision.action === 'block') {
    return res.status(403).json({ status: 'blocked', reason: decision.reason });
  }
  if (decision.action === 'challenge' || decision.action === 'step_up') {
    // e.g., require 2FA code, or delay transaction until review
    return res.status(200).json({ status: 'challenge', required: ['2fa', 'manual_review'], risk: risk.score });
  }

  // If allowed: perform transaction (placeholder)
  // TODO: plug actual payment/transfer API and guard with two-party auth
  return res.status(200).json({ status: 'approved', risk: risk.score });
});

// Admin endpoint to fetch user history (demo only)
app.get('/admin/history/:userId', (req, res) => {
  const hist = userHistoryStore.get(req.params.userId) || { ips: [], devices: [], timestamps: [] };
  res.json({
    ips: Array.from(hist.ips || []),
    devices: Array.from(hist.devices || []),
    recentAttempts: hist.timestamps || [],
  });
});

// Basic health
app.get('/health', (req, res) => res.json({ ok: true }));

app.listen(PORT, () => {
  console.log(`Fraud protection demo running on port ${PORT}`);
  if (!redisClient) console.log('Redis not configured — using in-memory rate limiting fallback');
});

https://www.healthymealplans8.blogspot.com/2024/10/healthy-meal-planning-guide-healthy.html?zx=5810ac80627fe74f
https://151b3cyhp08fjpm3sgow4wdndv.hop.clickbank.net

badbackadvise.blogspot.com/2019/09/bad-back-pain-advise.html
da6a32ki-fm1zlecjd8dqdbm27.hop.clickbank.net

https://658bdavqqs9r9p1ae30yod2k5p.hop.clickbank.net/?&traffic_source=pinterest&traffic_type=organic
https://hop.clickbank.net/?affiliate=devoraels7&vendor=lbjuice&pid=16&tid=G-C5K75BE0QE
https://clearobstacles.blogspot.com

https://www.67d63gsoluyevslvo3vafl5s1k.hop.clickbank.net/?cbpage=customplan&tid=G8Q388G9K2G
https://5a608qshsu1gkdnoqcumcl5nd7.hop.clickbank.net/?&extclid=https://5a608qshsu1gkdnoqcumcl5nd7.hop.clickbank.net/?&extclid=G-1Y1K28SDRY

https://0d1b9xsiknaohr0-n9zi2w4x0f.hop.clickbank.net

https://d15649mkoq6-6s2rbrh2dt7tao.hop.clickbank.net

https://clearobstacles.blogspot.com

https://2c86fautrwdual09uhxruc2wbo.hop.clickbank.net/rose2white/bluezy32

https://700d4ankpy3uekb5pm-ox92yfl.hop.clickbank.net

480a5n0pko-2jpuksl0qp7azex.hop.clickbank.net-
https://hop.clickbank.net/?vendor=livpure&affiliate=bluezy32&lid=1&tid=G-GV0426PE8H
d9014evcrsz3jqq2v0u6zexhfg.hop.clickbank.net/?tid=GQ8DZ25YVT1/rose2white/bluezy32

healthymealplans8.blogspot.com

09342gxett8ejdu7ichmrl6r6p.hop.clickbank.net-
/**
 * fraud-protect-app.js
 * Minimal layered fraud protection example (Express)
 *
 * Features:
 * - Rate limiter with Redis fallback
 * - Simple device/IP fingerprint
 * - Risk scoring engine (rules)
 * - Challenge escalation: allow / require captcha or 2FA or block
 * - Event logging and webhook alert
 */

const express = require('express');
const rateLimit = require('express-rate-limit');
const RedisStore = require('rate-limit-redis');
const redis = require('redis');
const geoip = require('geoip-lite');
const bodyParser = require('body-parser');
const fetch = require('node-fetch'); // for alert webhook
const helmet = require('helmet');
const cookieParser = require('cookie-parser');

const PORT = process.env.PORT || 3000;
const REDIS_URL = process.env.REDIS_URL || null; // set to redis://... to enable
const ALERT_WEBHOOK = process.env.ALERT_WEBHOOK || null; // optional webhook for high-risk events

// Basic in-memory store for fingerprint history (demo only) - replace with DB in prod
const userHistoryStore = new Map(); // key = userId (or email), value = { ips: Set, devices: Set, timestamps: [] }
const globalIPBlacklist = new Set(['203.0.113.45']); // example blacklisted IP
const emailDomainBlacklist = new Set(['fraudmail.com']);

// Create Redis client if URL provided
let redisClient = null;
if (REDIS_URL) {
  redisClient = redis.createClient({ url: REDIS_URL });
  redisClient.connect().catch(err => {
    console.error('Redis connect failed:', err);
    redisClient = null;
  });
}

// Rate limiter config (login endpoint example)
const createRateLimiter = (max, windowMs) => {
  if (redisClient) {
    return rateLimit({
      windowMs,
      max,
      standardHeaders: true,
      legacyHeaders: false,
      store: new RedisStore({
        sendCommand: (...args) => redisClient.sendCommand(args),
      }),
      keyGenerator: (req) => {
        // Use IP + user identifier (if present) to avoid attackers rotating IPs
        return req.ip + '::' + (req.body?.email || req.query?.email || 'anon');
      },
    });
  } else {
    // fallback memory limiter
    return rateLimit({
      windowMs,
      max,
      standardHeaders: true,
      legacyHeaders: false,
      keyGenerator: (req) => req.ip + '::' + (req.body?.email || req.query?.email || 'anon'),
    });
  }
};

// Basic fingerprint extraction
function makeFingerprint(req) {
  // Combine elements that are common and accessible server-side
  const ua = req.headers['user-agent'] || '';
  const ip = req.ip || req.connection?.remoteAddress || 'unknown';
  const acceptLang = req.headers['accept-language'] || '';
  const forwarded = req.headers['x-forwarded-for'] || '';
  const flash = req.headers['user-agent-platform'] || ''; // placeholder

  // Simple hash (not cryptographic here)
  const raw = [ua, ip, acceptLang, forwarded, flash].join('|');
  const hash = require('crypto').createHash('sha256').update(raw).digest('hex');
  return { hash, ua, ip, acceptLang, forwarded };
}

// Rule-based risk scoring function
function scoreRisk({ userId, email, ip, fingerprintHash, ua, payload }) {
  let score = 0;
  const reasons = [];

  // 1) IP blacklists
  if (globalIPBlacklist.has(ip)) {
    score += 50; reasons.push('ip_blacklist');
  }

  // 2) Email domain blacklist
  const domain = (email || '').split('@')[1]?.toLowerCase();
  if (domain && emailDomainBlacklist.has(domain)) {
    score += 40; reasons.push('email_domain_blacklist');
  }

  // 3) Geo mismatch: check geoip country vs claimed country (if provided)
  const geo = geoip.lookup(ip);
  const country = geo?.country || '??';
  if (payload?.declared_country && payload.declared_country !== country) {
    score += 20; reasons.push(`country_mismatch server:${country} declared:${payload.declared_country}`);
  }

  // 4) Velocity - many attempts from same userId or IP in short time
  const history = userHistoryStore.get(userId) || { ips: new Set(), devices: new Set(), timestamps: [] };
  const now = Date.now();
  const recentTimestamps = history.timestamps.filter(t => now - t < 10 * 60 * 1000); // 10min window
  if (recentTimestamps.length > 5) { score += 25; reasons.push('high_velocity'); }

  // 5) Device/IP churn - many different IPs/devices for the same user
  if (history.ips && history.ips.size > 3) { score += 15; reasons.push('ip_churn'); }
  if (history.devices && history.devices.size > 3) { score += 15; reasons.push('device_churn'); }

  // 6) Known risky UA patterns (simple heuristics)
  if (ua && /curl|wget|scrapy|bot|python-requests/i.test(ua)) {
    score += 10; reasons.push('suspicious_user_agent');
  }

  // 7) New account + high transaction amount
  if (payload?.account_age_days !== undefined && payload.account_age_days < 2 && payload?.amount && payload.amount > 200) {
    score += 30; reasons.push('new_account_large_amount');
  }

  // 8) Fingerprint mismatch with previous known device for same user
  if (history.devices && history.devices.size > 0 && !history.devices.has(fingerprintHash)) {
    score += 10; reasons.push('new_device_for_user');
  }

  // Normalize score
  if (score > 100) score = 100;

  return { score, reasons, country };
}

// Action decision based on risk score
function decideAction(risk) {
  // risk.score is 0..100
  if (risk.score >= 80) return { action: 'block', reason: 'high_risk' };
  if (risk.score >= 50) return { action: 'challenge', reason: 'require_2fa_or_captcha' };
  if (risk.score >= 30) return { action: 'step_up', reason: 'require_additional_verification' };
  return { action: 'allow', reason: 'low_risk' };
}

// Simple logging + optional webhook for high-risk
async function logEvent(type, details) {
  const entry = { ts: new Date().toISOString(), type, details };
  console.log('FRAUD_EVENT', JSON.stringify(entry));
  try {
    if (ALERT_WEBHOOK && details && details.risk && details.risk.score >= 50) {
      await fetch(ALERT_WEBHOOK, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(entry),
      });
    }
  } catch (err) {
    console.warn('failed to send alert webhook', err);
  }
}

// Express app
const app = express();
app.use(helmet());
app.set('trust proxy', true); // if behind load balancer
app.use(bodyParser.json());
app.use(cookieParser());

// Rate limiter for login route: 10 attempts per 10 minutes per ip+email (customizable)
const loginLimiter = createRateLimiter(10, 10 * 60 * 1000);
const transactionLimiter = createRateLimiter(20, 60 * 60 * 1000); // example for transaction endpoint

// Example /login endpoint
app.post('/login', loginLimiter, async (req, res) => {
  const { email } = req.body;
  const userId = (email || '').toLowerCase();
  const fp = makeFingerprint(req);
  const payload = {
    declared_country: req.body.declared_country,
    account_age_days: req.body.account_age_days,
  };

  // Score risk
  const risk = scoreRisk({
    userId,
    email,
    ip: fp.ip,
    fingerprintHash: fp.hash,
    ua: fp.ua,
    payload,
  });

  const decision = decideAction(risk);

  await logEvent('login_attempt', { userId, email, ip: fp.ip, fingerprint: fp.hash, risk, decision });

  // Update history store
  const hist = userHistoryStore.get(userId) || { ips: new Set(), devices: new Set(), timestamps: [] };
  hist.ips.add(fp.ip);
  hist.devices.add(fp.hash);
  hist.timestamps.push(Date.now());
  // Keep last 100 timestamps
  if (hist.timestamps.length > 100) hist.timestamps = hist.timestamps.slice(-100);
  userHistoryStore.set(userId, hist);

  // Respond based on decision
  if (decision.action === 'block') {
    return res.status(403).json({ status: 'blocked', reason: decision.reason });
  }
  if (decision.action === 'challenge') {
    // Return that frontend must show CAPTCHA or require 2FA
    return res.status(200).json({ status: 'challenge', challenge: '2fa_or_captcha', reason: decision.reason });
  }
  // Otherwise proceed with normal login flow (authenticate here)
  // NOTE: actual authentication (password check, bcrypt, etc) should happen AFTER or before scoring depending on design.
  return res.status(200).json({ status: 'ok', risk: risk.score, reason: 'proceed_with_auth' });
});

// Example /transaction endpoint (higher-security)
app.post('/transaction', transactionLimiter, async (req, res) => {
  // Expect payload: { userId, amount, account_age_days, declared_country, email }
  const { userId, amount, account_age_days, declared_country, email } = req.body;
  if (!userId) return res.status(400).json({ error: 'missing userId' });

  const fp = makeFingerprint(req);
  const risk = scoreRisk({
    userId,
    email,
    ip: fp.ip,
    fingerprintHash: fp.hash,
    ua: fp.ua,
    payload: { account_age_days, amount, declared_country },
  });
  const decision = decideAction(risk);
  await logEvent('transaction_attempt', { userId, amount, ip: fp.ip, risk, decision });

  // Implement step-up behavior
  if (decision.action === 'block') {
    return res.status(403).json({ status: 'blocked', reason: decision.reason });
  }
  if (decision.action === 'challenge' || decision.action === 'step_up') {
    // e.g., require 2FA code, or delay transaction until review
    return res.status(200).json({ status: 'challenge', required: ['2fa', 'manual_review'], risk: risk.score });
  }

  // If allowed: perform transaction (placeholder)
  // TODO: plug actual payment/transfer API and guard with two-party auth
  return res.status(200).json({ status: 'approved', risk: risk.score });
});

// Admin endpoint to fetch user history (demo only)
app.get('/admin/history/:userId', (req, res) => {
  const hist = userHistoryStore.get(req.params.userId) || { ips: [], devices: [], timestamps: [] };
  res.json({
    ips: Array.from(hist.ips || []),
    devices: Array.from(hist.devices || []),
    recentAttempts: hist.timestamps || [],
  });
});

// Basic health
app.get('/health', (req, res) => res.json({ ok: true }));

app.listen(PORT, () => {
  console.log(`Fraud protection demo running on port ${PORT}`);
  if (!redisClient) console.log('Redis not configured — using in-memory rate limiting fallback');
});


b6f4a2uipj4t6q8ta5x1sl3wcw.hop.clickbank.net/?&traffic_source=pinterest&traffic_type=organic

d7827gwjpsz2qsu-neav2864zf.hop.clickbank.net/?tid=G_CBZ4PYWLEK/rose2white/bluezy32

rwww.oothealth.myhealthmatters.life
1e4c3dsrupbfvdsopjegw-q94l.hop.clickbank.net/?tid=G_32SN8ZTD6X/rose2white/bluezy32

https://0e3eflxfmt32ygldqbmduzv9db.hop.clickbank.net/?&extclid=G-F8V5KP5J3C

1cecdh2ou09ctngiwmvj462u91.hop.clickbank.net/?tid=G_MT13KN8BBZ
29d981uf3gk2yoe47jr2rpaw0z.hop.clickbank.net

docs.google.com/document/d/e/2PACX-1vS8qzgVncHyQzfHcNf408tVXdunO8nx4KRUd0Zn0McQ7QnD6DLuPGtnyQpOvcydEs1LPVCyyesvOM1b/pub

sup.myhealthmatters.life/blogs/news
https://308491titlavfkfdxegnij2qbr.hop.clickbank.net

https://9706a7osstcxhmcfwl33tdxr9s.hop.clickbank.net

https://989cb4ko1dcdqekin1zl0qv1s2.hop.clickbank.net

https://2d4ae3puvmi-mdbcoqxalx0tff.hop.clickbank.net/?&extclid=G-5B2L2M9QR1

4be9damjtxzzdp87w42gtnoo2o.hop.clickbank.net
fd5145ujqm3zbu2yslz6wj2mkc.hop.clickbank.net/?&traffic_source=pinterest&traffic_type=organic&extclid=Tinyurl.com-245gkxpu

https://48b451ofwopdolmcjvrlm637uo.hop.clickbank.net
https://be34daip0pn8mcb4ofnj6z-u81.hop.clickbank.net

 https://fe29aq3eiu2frro7nbtkww-l6y.hop.clickbank.net/?&extclid=G-W6TNPDSRBZ                    G-W6TNPDSRBZ   
https://a9ce3zsqhy52dy6li6y6l9so4j.hop.clickbank.net
https://810f05wjtv319y1dtp0iiqak5p.hop.clickbank.net/?&extclid=G-H504X2Y5H3

https://775da8tkykm9-j82ppkdwaavfx.hop.clickbank.net

https://904c73rnlm2sbu5lmcsek8smfv.hop.clickbank.net

https://e4c414wfsn7oit84toka5g5qy5.hop.clickbank.net
https://652494tenk4q4m6anmhcis9s33.hop.clickbank.net




https://f57157ogqkcwak2hkjwlj1cm0w.hop.clickbank.net


https://b7d46yjl1hiduliloaheh8tx9q.hop.clickbank.net
https://b7d46yjl1hiduliloaheh8tx9q.hop.clickbank.net

"
https://20613arm3qnzme8pet9-ip4x6z.hop.clickbank.net
"

https://tinyurl.com/2axsvz23
https://b9e224npgp505q7fyapsciub0o.hop.clickbank.net/?&extclid=G-NMPBDG0TMW
https://b9e224npgp505q7fyapsciub0o.hop.clickbank.net/?&extclid=G-NMPBDG0TMW
https://dffacltkjt35kjhp0dldkblr79.hop.clickbank.net/?&extclid=G-F8V5KP5J3C

https://5f2729xhfwar9w15qmgsdstm43.hop.clickbank.net/?&extclid=G-N8SS31P83F   compromised=comp

https://248229nlqmzpfmcaudfjhg1kck.hop.clickbank.net/?&extclid=G-NMPBDG0TMW - /**
 * fraud-protect-app.js
 * Minimal layered fraud protection example (Express)
 *
 * Features:
 * - Rate limiter with Redis fallback
 * - Simple device/IP fingerprint
 * - Risk scoring engine (rules)
 * - Challenge escalation: allow / require captcha or 2FA or block
 * - Event logging and webhook alert
 */

const express = require('express');
const rateLimit = require('express-rate-limit');
const RedisStore = require('rate-limit-redis');
const redis = require('redis');
const geoip = require('geoip-lite');
const bodyParser = require('body-parser');
const fetch = require('node-fetch'); // for alert webhook
const helmet = require('helmet');
const cookieParser = require('cookie-parser');

const PORT = process.env.PORT || 3000;
const REDIS_URL = process.env.REDIS_URL || null; // set to redis://... to enable
const ALERT_WEBHOOK = process.env.ALERT_WEBHOOK || null; // optional webhook for high-risk events

// Basic in-memory store for fingerprint history (demo only) - replace with DB in prod
const userHistoryStore = new Map(); // key = userId (or email), value = { ips: Set, devices: Set, timestamps: [] }
const globalIPBlacklist = new Set(['203.0.113.45']); // example blacklisted IP
const emailDomainBlacklist = new Set(['fraudmail.com']);

// Create Redis client if URL provided
let redisClient = null;
if (REDIS_URL) {
  redisClient = redis.createClient({ url: REDIS_URL });
  redisClient.connect().catch(err => {
    console.error('Redis connect failed:', err);
    redisClient = null;
  });
}

// Rate limiter config (login endpoint example)
const createRateLimiter = (max, windowMs) => {
  if (redisClient) {
    return rateLimit({
      windowMs,
      max,
      standardHeaders: true,
      legacyHeaders: false,
      store: new RedisStore({
        sendCommand: (...args) => redisClient.sendCommand(args),
      }),
      keyGenerator: (req) => {
        // Use IP + user identifier (if present) to avoid attackers rotating IPs
        return req.ip + '::' + (req.body?.email || req.query?.email || 'anon');
      },
    });
  } else {
    // fallback memory limiter
    return rateLimit({
      windowMs,
      max,
      standardHeaders: true,
      legacyHeaders: false,
      keyGenerator: (req) => req.ip + '::' + (req.body?.email || req.query?.email || 'anon'),
    });
  }
};

// Basic fingerprint extraction
function makeFingerprint(req) {
  // Combine elements that are common and accessible server-side
  const ua = req.headers['user-agent'] || '';
  const ip = req.ip || req.connection?.remoteAddress || 'unknown';
  const acceptLang = req.headers['accept-language'] || '';
  const forwarded = req.headers['x-forwarded-for'] || '';
  const flash = req.headers['user-agent-platform'] || ''; // placeholder

  // Simple hash (not cryptographic here)
  const raw = [ua, ip, acceptLang, forwarded, flash].join('|');
  const hash = require('crypto').createHash('sha256').update(raw).digest('hex');
  return { hash, ua, ip, acceptLang, forwarded };
}

// Rule-based risk scoring function
function scoreRisk({ userId, email, ip, fingerprintHash, ua, payload }) {
  let score = 0;
  const reasons = [];

  // 1) IP blacklists
  if (globalIPBlacklist.has(ip)) {
    score += 50; reasons.push('ip_blacklist');
  }

  // 2) Email domain blacklist
  const domain = (email || '').split('@')[1]?.toLowerCase();
  if (domain && emailDomainBlacklist.has(domain)) {
    score += 40; reasons.push('email_domain_blacklist');
  }

  // 3) Geo mismatch: check geoip country vs claimed country (if provided)
  const geo = geoip.lookup(ip);
  const country = geo?.country || '??';
  if (payload?.declared_country && payload.declared_country !== country) {
    score += 20; reasons.push(`country_mismatch server:${country} declared:${payload.declared_country}`);
  }

  // 4) Velocity - many attempts from same userId or IP in short time
  const history = userHistoryStore.get(userId) || { ips: new Set(), devices: new Set(), timestamps: [] };
  const now = Date.now();
  const recentTimestamps = history.timestamps.filter(t => now - t < 10 * 60 * 1000); // 10min window
  if (recentTimestamps.length > 5) { score += 25; reasons.push('high_velocity'); }

  // 5) Device/IP churn - many different IPs/devices for the same user
  if (history.ips && history.ips.size > 3) { score += 15; reasons.push('ip_churn'); }
  if (history.devices && history.devices.size > 3) { score += 15; reasons.push('device_churn'); }

  // 6) Known risky UA patterns (simple heuristics)
  if (ua && /curl|wget|scrapy|bot|python-requests/i.test(ua)) {
    score += 10; reasons.push('suspicious_user_agent');
  }

  // 7) New account + high transaction amount
  if (payload?.account_age_days !== undefined && payload.account_age_days < 2 && payload?.amount && payload.amount > 200) {
    score += 30; reasons.push('new_account_large_amount');
  }

  // 8) Fingerprint mismatch with previous known device for same user
  if (history.devices && history.devices.size > 0 && !history.devices.has(fingerprintHash)) {
    score += 10; reasons.push('new_device_for_user');
  }

  // Normalize score
  if (score > 100) score = 100;

  return { score, reasons, country };
}

// Action decision based on risk score
function decideAction(risk) {
  // risk.score is 0..100
  if (risk.score >= 80) return { action: 'block', reason: 'high_risk' };
  if (risk.score >= 50) return { action: 'challenge', reason: 'require_2fa_or_captcha' };
  if (risk.score >= 30) return { action: 'step_up', reason: 'require_additional_verification' };
  return { action: 'allow', reason: 'low_risk' };
}

// Simple logging + optional webhook for high-risk
async function logEvent(type, details) {
  const entry = { ts: new Date().toISOString(), type, details };
  console.log('FRAUD_EVENT', JSON.stringify(entry));
  try {
    if (ALERT_WEBHOOK && details && details.risk && details.risk.score >= 50) {
      await fetch(ALERT_WEBHOOK, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(entry),
      });
    }
  } catch (err) {
    console.warn('failed to send alert webhook', err);
  }
}

// Express app
const app = express();
app.use(helmet());
app.set('trust proxy', true); // if behind load balancer
app.use(bodyParser.json());
app.use(cookieParser());

// Rate limiter for login route: 10 attempts per 10 minutes per ip+email (customizable)
const loginLimiter = createRateLimiter(10, 10 * 60 * 1000);
const transactionLimiter = createRateLimiter(20, 60 * 60 * 1000); // example for transaction endpoint

// Example /login endpoint
app.post('/login', loginLimiter, async (req, res) => {
  const { email } = req.body;
  const userId = (email || '').toLowerCase();
  const fp = makeFingerprint(req);
  const payload = {
    declared_country: req.body.declared_country,
    account_age_days: req.body.account_age_days,
  };

  // Score risk
  const risk = scoreRisk({
    userId,
    email,
    ip: fp.ip,
    fingerprintHash: fp.hash,
    ua: fp.ua,
    payload,
  });

  const decision = decideAction(risk);

  await logEvent('login_attempt', { userId, email, ip: fp.ip, fingerprint: fp.hash, risk, decision });

  // Update history store
  const hist = userHistoryStore.get(userId) || { ips: new Set(), devices: new Set(), timestamps: [] };
  hist.ips.add(fp.ip);
  hist.devices.add(fp.hash);
  hist.timestamps.push(Date.now());
  // Keep last 100 timestamps
  if (hist.timestamps.length > 100) hist.timestamps = hist.timestamps.slice(-100);
  userHistoryStore.set(userId, hist);

  // Respond based on decision
  if (decision.action === 'block') {
    return res.status(403).json({ status: 'blocked', reason: decision.reason });
  }
  if (decision.action === 'challenge') {
    // Return that frontend must show CAPTCHA or require 2FA
    return res.status(200).json({ status: 'challenge', challenge: '2fa_or_captcha', reason: decision.reason });
  }
  // Otherwise proceed with normal login flow (authenticate here)
  // NOTE: actual authentication (password check, bcrypt, etc) should happen AFTER or before scoring depending on design.
  return res.status(200).json({ status: 'ok', risk: risk.score, reason: 'proceed_with_auth' });
});

// Example /transaction endpoint (higher-security)
app.post('/transaction', transactionLimiter, async (req, res) => {
  // Expect payload: { userId, amount, account_age_days, declared_country, email }
  const { userId, amount, account_age_days, declared_country, email } = req.body;
  if (!userId) return res.status(400).json({ error: 'missing userId' });

  const fp = makeFingerprint(req);
  const risk = scoreRisk({
    userId,
    email,
    ip: fp.ip,
    fingerprintHash: fp.hash,
    ua: fp.ua,
    payload: { account_age_days, amount, declared_country },
  });
  const decision = decideAction(risk);
  await logEvent('transaction_attempt', { userId, amount, ip: fp.ip, risk, decision });

  // Implement step-up behavior
  if (decision.action === 'block') {
    return res.status(403).json({ status: 'blocked', reason: decision.reason });
  }
  if (decision.action === 'challenge' || decision.action === 'step_up') {
    // e.g., require 2FA code, or delay transaction until review
    return res.status(200).json({ status: 'challenge', required: ['2fa', 'manual_review'], risk: risk.score });
  }

  // If allowed: perform transaction (placeholder)
  // TODO: plug actual payment/transfer API and guard with two-party auth
  return res.status(200).json({ status: 'approved', risk: risk.score });
});

// Admin endpoint to fetch user history (demo only)
app.get('/admin/history/:userId', (req, res) => {
  const hist = userHistoryStore.get(req.params.userId) || { ips: [], devices: [], timestamps: [] };
  res.json({
    ips: Array.from(hist.ips || []),
    devices: Array.from(hist.devices || []),
    recentAttempts: hist.timestamps || [],
  });
});

// Basic health
app.get('/health', (req, res) => res.json({ ok: true }));

app.listen(PORT, () => {
  console.log(`Fraud protection demo running on port ${PORT}`);
  if (!redisClient) console.log('Redis not configured — using in-memory rate limiting fallback');
});

"https://tiktok.com/@healthuniverse.website/video/7490894760203291937   
https://buff.ly/8qA8zSO."

https://ca3dby-qgy5z3sbp3fcjsgy784.hop.clickbank.net-/**
 * fraud-protect-app.js
 * Minimal layered fraud protection example (Express)
 *
 * Features:
 * - Rate limiter with Redis fallback
 * - Simple device/IP fingerprint
 * - Risk scoring engine (rules)
 * - Challenge escalation: allow / require captcha or 2FA or block
 * - Event logging and webhook alert
 */

const express = require('express');
const rateLimit = require('express-rate-limit');
const RedisStore = require('rate-limit-redis');
const redis = require('redis');
const geoip = require('geoip-lite');
const bodyParser = require('body-parser');
const fetch = require('node-fetch'); // for alert webhook
const helmet = require('helmet');
const cookieParser = require('cookie-parser');

const PORT = process.env.PORT || 3000;
const REDIS_URL = process.env.REDIS_URL || null; // set to redis://... to enable
const ALERT_WEBHOOK = process.env.ALERT_WEBHOOK || null; // optional webhook for high-risk events

// Basic in-memory store for fingerprint history (demo only) - replace with DB in prod
const userHistoryStore = new Map(); // key = userId (or email), value = { ips: Set, devices: Set, timestamps: [] }
const globalIPBlacklist = new Set(['203.0.113.45']); // example blacklisted IP
const emailDomainBlacklist = new Set(['fraudmail.com']);

// Create Redis client if URL provided
let redisClient = null;
if (REDIS_URL) {
  redisClient = redis.createClient({ url: REDIS_URL });
  redisClient.connect().catch(err => {
    console.error('Redis connect failed:', err);
    redisClient = null;
  });
}

// Rate limiter config (login endpoint example)
const createRateLimiter = (max, windowMs) => {
  if (redisClient) {
    return rateLimit({
      windowMs,
      max,
      standardHeaders: true,
      legacyHeaders: false,
      store: new RedisStore({
        sendCommand: (...args) => redisClient.sendCommand(args),
      }),
      keyGenerator: (req) => {
        // Use IP + user identifier (if present) to avoid attackers rotating IPs
        return req.ip + '::' + (req.body?.email || req.query?.email || 'anon');
      },
    });
  } else {
    // fallback memory limiter
    return rateLimit({
      windowMs,
      max,
      standardHeaders: true,
      legacyHeaders: false,
      keyGenerator: (req) => req.ip + '::' + (req.body?.email || req.query?.email || 'anon'),
    });
  }
};

// Basic fingerprint extraction
function makeFingerprint(req) {
  // Combine elements that are common and accessible server-side
  const ua = req.headers['user-agent'] || '';
  const ip = req.ip || req.connection?.remoteAddress || 'unknown';
  const acceptLang = req.headers['accept-language'] || '';
  const forwarded = req.headers['x-forwarded-for'] || '';
  const flash = req.headers['user-agent-platform'] || ''; // placeholder

  // Simple hash (not cryptographic here)
  const raw = [ua, ip, acceptLang, forwarded, flash].join('|');
  const hash = require('crypto').createHash('sha256').update(raw).digest('hex');
  return { hash, ua, ip, acceptLang, forwarded };
}

// Rule-based risk scoring function
function scoreRisk({ userId, email, ip, fingerprintHash, ua, payload }) {
  let score = 0;
  const reasons = [];

  // 1) IP blacklists
  if (globalIPBlacklist.has(ip)) {
    score += 50; reasons.push('ip_blacklist');
  }

  // 2) Email domain blacklist
  const domain = (email || '').split('@')[1]?.toLowerCase();
  if (domain && emailDomainBlacklist.has(domain)) {
    score += 40; reasons.push('email_domain_blacklist');
  }

  // 3) Geo mismatch: check geoip country vs claimed country (if provided)
  const geo = geoip.lookup(ip);
  const country = geo?.country || '??';
  if (payload?.declared_country && payload.declared_country !== country) {
    score += 20; reasons.push(`country_mismatch server:${country} declared:${payload.declared_country}`);
  }

  // 4) Velocity - many attempts from same userId or IP in short time
  const history = userHistoryStore.get(userId) || { ips: new Set(), devices: new Set(), timestamps: [] };
  const now = Date.now();
  const recentTimestamps = history.timestamps.filter(t => now - t < 10 * 60 * 1000); // 10min window
  if (recentTimestamps.length > 5) { score += 25; reasons.push('high_velocity'); }

  // 5) Device/IP churn - many different IPs/devices for the same user
  if (history.ips && history.ips.size > 3) { score += 15; reasons.push('ip_churn'); }
  if (history.devices && history.devices.size > 3) { score += 15; reasons.push('device_churn'); }

  // 6) Known risky UA patterns (simple heuristics)
  if (ua && /curl|wget|scrapy|bot|python-requests/i.test(ua)) {
    score += 10; reasons.push('suspicious_user_agent');
  }

  // 7) New account + high transaction amount
  if (payload?.account_age_days !== undefined && payload.account_age_days < 2 && payload?.amount && payload.amount > 200) {
    score += 30; reasons.push('new_account_large_amount');
  }

  // 8) Fingerprint mismatch with previous known device for same user
  if (history.devices && history.devices.size > 0 && !history.devices.has(fingerprintHash)) {
    score += 10; reasons.push('new_device_for_user');
  }

  // Normalize score
  if (score > 100) score = 100;

  return { score, reasons, country };
}

// Action decision based on risk score
function decideAction(risk) {
  // risk.score is 0..100
  if (risk.score >= 80) return { action: 'block', reason: 'high_risk' };
  if (risk.score >= 50) return { action: 'challenge', reason: 'require_2fa_or_captcha' };
  if (risk.score >= 30) return { action: 'step_up', reason: 'require_additional_verification' };
  return { action: 'allow', reason: 'low_risk' };
}

// Simple logging + optional webhook for high-risk
async function logEvent(type, details) {
  const entry = { ts: new Date().toISOString(), type, details };
  console.log('FRAUD_EVENT', JSON.stringify(entry));
  try {
    if (ALERT_WEBHOOK && details && details.risk && details.risk.score >= 50) {
      await fetch(ALERT_WEBHOOK, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify(entry),
      });
    }
  } catch (err) {
    console.warn('failed to send alert webhook', err);
  }
}

// Express app
const app = express();
app.use(helmet());
app.set('trust proxy', true); // if behind load balancer
app.use(bodyParser.json());
app.use(cookieParser());

// Rate limiter for login route: 10 attempts per 10 minutes per ip+email (customizable)
const loginLimiter = createRateLimiter(10, 10 * 60 * 1000);
const transactionLimiter = createRateLimiter(20, 60 * 60 * 1000); // example for transaction endpoint

// Example /login endpoint
app.post('/login', loginLimiter, async (req, res) => {
  const { email } = req.body;
  const userId = (email || '').toLowerCase();
  const fp = makeFingerprint(req);
  const payload = {
    declared_country: req.body.declared_country,
    account_age_days: req.body.account_age_days,
  };

  // Score risk
  const risk = scoreRisk({
    userId,
    email,
    ip: fp.ip,
    fingerprintHash: fp.hash,
    ua: fp.ua,
    payload,
  });

  const decision = decideAction(risk);

  await logEvent('login_attempt', { userId, email, ip: fp.ip, fingerprint: fp.hash, risk, decision });

  // Update history store
  const hist = userHistoryStore.get(userId) || { ips: new Set(), devices: new Set(), timestamps: [] };
  hist.ips.add(fp.ip);
  hist.devices.add(fp.hash);
  hist.timestamps.push(Date.now());
  // Keep last 100 timestamps
  if (hist.timestamps.length > 100) hist.timestamps = hist.timestamps.slice(-100);
  userHistoryStore.set(userId, hist);

  // Respond based on decision
  if (decision.action === 'block') {
    return res.status(403).json({ status: 'blocked', reason: decision.reason });
  }
  if (decision.action === 'challenge') {
    // Return that frontend must show CAPTCHA or require 2FA
    return res.status(200).json({ status: 'challenge', challenge: '2fa_or_captcha', reason: decision.reason });
  }
  // Otherwise proceed with normal login flow (authenticate here)
  // NOTE: actual authentication (password check, bcrypt, etc) should happen AFTER or before scoring depending on design.
  return res.status(200).json({ status: 'ok', risk: risk.score, reason: 'proceed_with_auth' });
});

// Example /transaction endpoint (higher-security)
app.post('/transaction', transactionLimiter, async (req, res) => {
  // Expect payload: { userId, amount, account_age_days, declared_country, email }
  const { userId, amount, account_age_days, declared_country, email } = req.body;
  if (!userId) return res.status(400).json({ error: 'missing userId' });

  const fp = makeFingerprint(req);
  const risk = scoreRisk({
    userId,
    email,
    ip: fp.ip,
    fingerprintHash: fp.hash,
    ua: fp.ua,
    payload: { account_age_days, amount, declared_country },
  });
  const decision = decideAction(risk);
  await logEvent('transaction_attempt', { userId, amount, ip: fp.ip, risk, decision });

  // Implement step-up behavior
  if (decision.action === 'block') {
    return res.status(403).json({ status: 'blocked', reason: decision.reason });
  }
  if (decision.action === 'challenge' || decision.action === 'step_up') {
    // e.g., require 2FA code, or delay transaction until review
    return res.status(200).json({ status: 'challenge', required: ['2fa', 'manual_review'], risk: risk.score });
  }

  // If allowed: perform transaction (placeholder)
  // TODO: plug actual payment/transfer API and guard with two-party auth
  return res.status(200).json({ status: 'approved', risk: risk.score });
});

// Admin endpoint to fetch user history (demo only)
app.get('/admin/history/:userId', (req, res) => {
  const hist = userHistoryStore.get(req.params.userId) || { ips: [], devices: [], timestamps: [] };
  res.json({
    ips: Array.from(hist.ips || []),
    devices: Array.from(hist.devices || []),
    recentAttempts: hist.timestamps || [],
  });
});

// Basic health
app.get('/health', (req, res) => res.json({ ok: true }));

app.listen(PORT, () => {
  console.log(`Fraud protection demo running on port ${PORT}`);
  if (!redisClient) console.log('Redis not configured — using in-memory rate limiting fallback');
});

https://hop.clickbank.net/?affiliate=bluezy32&vendor=gluco6&pid=vsl&tid=G-LGELBTZJX3

https://hop.clickbank.net/?affiliate=bluezy32&vendor=sumatonic&cbpage=welcome&tid=G-YB9LQE1D6Y








































































































































































































































































































































































































































































































































































































































































































































































































































































































